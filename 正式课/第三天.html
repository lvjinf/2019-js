<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /*
            变量提升：
            在代码执行之前，会提前把带var和function的变量提前声明。
            带var的只声明，带function的是既声明也定义
            在大括号{}中包着的function，是只声明不定义的，只提升等号左边的部分，return后边的也不提升。
            let和const是不存在变量提升的，但是有暂时性死区，在声明绝对不能调用；
    
            堆内存：就是用来存储引用数据类型
            栈内存：就是用来存储值类型，也提供代码的运行环境（作用域）
    
    
            作用域：
                    代码能够起作用的区域
                    全局作用域：页面一打开就会形成一个全局作用域，只有一个全局作用域。
                    私有作用域：函数一执行就会形成一个私有作用域，私有作用域可以有多个
                    块级作用域：针对let和const存在的一个作用域
    
    
                    var是全局作用域，let是私有作用域
                    全局变量：在全局声明的变量，我们称为全局变量
                    私有变量：在私有作用域声明的变量，我们称为私有变量，除此之外形参也是私有变量
    
                    作用域链：变量的查找机制，在某个私有作用域中存在某个变量，那么这个变量的取值，他是有自己的一套规律，先在自己的作用域中查找，如果不是自己作用域的变量，则再去上级作用域查找，找到即可，找不到就一直查找到window，如果还没有就报错。
    
                    上级作用域：是针对私有作用域来说的，函数执行形成了一个私有作用域，那么这个私有作用域的上级作用域是谁，是由这个函数在哪个作用域中定义决定的
    
                    函数执行的过程：先开辟一个私有作用域（栈内存），然后形参赋值，变量提升 代码从上到下执行
    
                    高阶函数：
    
        */

        // var x = 5;

        // function fn() {
        //     return function (y) {
        //         console.log(y + (++x));
        //     }
        // }
        // var f = fn(6);
        // f(7);
        // fn(8)(9);
        // f(10);
        // console.log(x);

        // var x = 0,//1
        //     y = 1;

        // function fn() {
        //     x += 2;
        //     fn = function (y) {
        //         console.log(y + (--x));//2 1
        //     };
        //     console.log(x, y);//5
        // }
        // fn(3);
        // fn(4);
        // console.log(x, y);//1 1


       /* 堆栈内存的销毁
            堆内存的销毁：
                1.谷歌浏览器，定时清除每隔一段时间就会通篇销毁一次，把js中没有被用到的地址全部清除
                2.火狐浏览器，计数清除，根据当前地址的引用个数，来决定这个地址是否要被销毁
            栈内存的销毁：
            全局作用域的销毁 只有当页面关闭的时候才会销毁
            私有作用域的销毁 只要函数的返回值是引用数据类型，那么作用域就不会被销毁

            栈溢出 内存泄漏：栈内存不够用

            闭包：就是一个变量的保护机制
                闭包首先是一个不销毁的作用域，用来保护变量，用来存储值。
                利用闭包我们可以实现模块化开发。
                闭包不能多用，多了容易引起内存泄漏。

            this：就是函数主体，事件绑定中的this就是当前绑定的元素
            自执行函数中的this是window
            我们可以通过看点的方式来确定this指向谁
            函数执行点前是谁this就是谁  没点就是window


        var btns = document.querySelectorAll('button');
        [...btns].foreach(item=>){
            item.onclick = function () {
                console.log(this)
            }
        }

自执行函数：
        (function(){
            console.log(1,this)
        })()

        ~function(){

        }()

        !function(){

        }()

        var obj = {
            name:'珠峰'；
            age:'9';

        }
        // (function(obj){
        //     obj.name = '中国'；
        //     obj = {};
        //     obj.age = 5000;
        //     console.log(obj.age)
        // })(obj)
        // console.log(obj.name)



// */      
//             name:'珠峰';
//             age:9;
//         }
//         (function(obj){
//             obj.name = '中国';
//             obj = {};
//             obj.age = 5000;
//             console.log(obj.age)
//         })(obj)
//         console.log(obj.name)
    // var a = {
    //     x:1
    // }
    // var b = a;
    // b.y = a = {
    //     qqq:123
    // }
    // console.log(a.x,b.x)

        // var num = 1;
        // var obj = {
        //     num:2
        // }
        // obj.fn = (function(num){
        //     this.num = num*2;
        //     num++;
        //     return function (n) {
        //         this.num += n;
        //         num++;
        //         cnsole.log(num)
        //     }
        // })(obj.num)
        // var fn = obj.fn;
        // fn(10);
        // obj.fn(20)
    </script>
</body>

</html>